数学の記号などをプログラムの関数で表す試みシリーズ 集合編

## 集合とは？

> **集合**は「ものの集まり」である[[1\]](https://ja.wikipedia.org/wiki/集合#cite_note-1)。集合の**元**（要素）として、集められる対象となる「もの」は、[数](https://ja.wikipedia.org/wiki/数)、[文字](https://ja.wikipedia.org/wiki/文字)、[記号](https://ja.wikipedia.org/wiki/記号)などをはじめ、どんなものでも（当然、集合でも）構わない。
>
> 一方で、どんな「集まり」でも集合と呼んでよいわけではない。その「集まり」が集合と呼ばれるためには、対象が「その集まりの元であるかどうかが不確定要素なしに一意に決定できる」ように定義されていなければならない。

wikiによるとこのように定義されている。



数学の言い回しは個人的にとてもわかりにくいので、得意なプログラムに置き換えて捉えていく。



まず**集合**は「ものの集まり」という事から、プログラムの**配列**に近しい

例えば「自然数1, 2, 3, 4からなる集合」であれば、プログラムだと以下のように表せるだろうし

```js
const A = [1, 2, 3, 4];
```



集められる対象は文字でも、記号でもいいのだから、以下も**集合**と呼べるだろう。

```js
const A = ["a", "b", "c"];
```



**集合**に含まれる１つ１つのモノを数学では**元**(最近は要素ともいうらしい)と呼ぶ。

プログラム的に捉えれば**集合**は**配列**、**元**は配列の**要素**として考えられる。



また定義には以下のような文言がある。



> > その「集まり」が集合と呼ばれるためには、対象が「その集まりの元であるかどうかが不確定要素なしに一意に決定できる」ように定義されていなければならない。



これは非常にわかりにくいが、プログラム的に考えれば

**「配列の中に重複する要素があってはいけない」**と言い換えられると思われる。



つまり以下は集合とは呼べないという事になる。

```js
const A = [1, 1, 2, 3, 4];
```



まとめると、数学の**集合**とはプログラム的には**「重複する要素のない配列**」と言える。



## 集合の表し方

### 外延的記法

$$
A = \{1, 2, 3, 4 \}
$$

これは「集合Aは自然数1,2,3,4の集まり」といことを表していて

数学では集合をこのように記述する方法を**外延的記法**と呼ぶ。

この書き方はプログラムの配列の書き方に近いので、プログラマーなら違和感は少ないだろう。



### 内包的記法

$$
A = \{x | xは10未満の正の奇数 \}
$$

これは**内包的記法**と呼ばれ、集合に含まれる要素の条件を明示する方法である。

この集合を**外延的記法**で表した場合は以下のようになる。


$$
A = \{1, 3, 5, 7, 9 \}
$$


## 有限集合と無限集合

集合は大きく**有限集合**と**無限集合**に分類される。



**有限集合**は集合の要素の数が**有限**

プログラムの**配列**も要素は**有限**なので近しい存在と思われる。



**無限集合**とは、名前のまんまだが、要素の数が**無限**の集合である。

例えば「自然数の集合」と言えば、自然数は無限にあるので、これは無限集合となる。



パソコンにはメモリがあり、メモリは有限なため、配列で**無限集合**を扱う事はできないと思われる。



## 集合の要素の個数

$$
集合Aの要素が有限であるとき、Aの要素の個数をn(A)と表す。
$$

プログラム的に捉えると

**「引数に配列Aを受け取り、その配列の要素数を返す関数がnである」** と言える。

コードにするとこのような感じである。



```js
// 集合の要素の個数を返す関数
function n(A) { return A.length; }

// 集合A
const A = [1, 2, 3, 4, 5];

// 集合Aの要素の数
const count = n(A);
```



## 空集合

$$
空集合とは要素を持たない集合であり \phi という記号で表す。 \\
また n(\phi) = 0 である
$$

空集合をプログラムで表すのであれば、**空配列**と言えるだろう。

```js
// 空集合
const phi = [];
```



空集合の要素の個数は当然ながら0なので、前項で定義した集合の要素の個数を返す関数 `n(A)`を使ってプログラムで表現するとこのようになるだろう。

```js
// 空集合
const phi = [];

// 空集合の要素の個数を取得
const count = n(phi);

console.log(count); // 0
```



いやー、なんかこれだけなのに美しい...



## 和集合

$$
２つの集合A,Bに対して,少なくともどちらか一方の集合に属する要素全体の集合のことを,AとBの和集合といい \\
A \cup Bと表す。
$$

例として以下のような集合A, Bがあった場合
$$
A = \{1, 2, 3, 4\} \\
B = \{2, 3, 4, 5\}
$$
A,B の 和集合は以下のようになる。
$$
A \cup B = \{1, 2, 3, 4, 5 \}
$$
和集合の要素の個数は5となる
$$
n(A \cup B) = 5
$$




この和集合の記号をプログラムの関数として実装する場合

**「引数に２つの配列を受け取り、２つの配列の要素を合算した配列を返す関数 を定義すること」** と考えられる。

※ただし、数学の集合は重複する要素を持たないので、プログラムでも配列に重複する要素を持たないように処理する必要がある点に注意



実際のプログラムにするとこのようになる。

```js
// 引数に２つの集合を取り、和集合を返す関数
function union(A, B) {
  // 配列を結合した上で、重複を取り除く
  return A.concat(B).filter((x, i, self) => {
    return self.indexOf(x) === i;
  })
}

// 集合A, B
const A = [1, 2, 3, 4];
const B = [2, 3, 4, 5];

// 集合A, Bの和集合
const A_or_B = union(A, B);

// 和集合の要素の数は5
const count = n(A_or_B);

console.log(count); // 5
```



数学で書いてるのとほぼ一緒...なんて美しいんだ...



## 積集合

$$
2つの集合A,Bに対して,両方の集合に属する要素全体の集合のことを,AとBの積集合といい \\
A \cap Bと表す。
$$

例として以下のような集合A, Bがあった場合
$$
A = \{1, 2, 3, 4\} \\
B = \{2, 3, 4, 5\}
$$
A,B の 積集合は以下のようになる。
$$
A \cap B = \{2, 3, 4 \}
$$
積集合の要素の個数は3となる
$$
n(A \cap B) = 3
$$


この積集合の記号をプログラムの関数として実装する場合

**「引数に２つの配列を受け取り、２つの配列に共通な要素を持った配列を返す関数 を定義すること」** と考えられる。



実際のプログラムにするとこのようになる。

```js
// 引数に２つの集合を取り、積集合を返す
function intersection(A, B) {
  // AとBに共通の要素のみ抽出する
  return A.filter((x) => {
    return B.indexOf(x) !== -1;
  })
}

// 集合A, B
const A = [1, 2, 3, 4];
const B = [2, 3, 4, 5];

// 集合A, Bの積集合
const A_and_B = intersection(A, B)

// 積集合の要素の数は3
const count = n(A_and_B);

console.log(count); // 3
```



## 和集合の要素の個数

集合の要素の個数に関していくつかのケースを確認してみる。

また前項までに定義した以下の関数を使ってプログラムでの表現にも取り組む。

- 集合の要素の個数を得る関数：n(A)
- 和集合を得る関数：union(A, B)
- 積集合を得る関数：intersection(A, B)

※引数のA, Bはいずれも集合(重複要素を持たない配列)とする。



### ケース①

$$
A \cap B = \phi のとき、A と B には共通の要素がないので \\
n(A \cup B) = n(A) + n(B)
$$



これをプログラムで確かめてみる。

```js
// A, Bには共通の要素がないので、まず共通の要素を持たない集合A, Bを用意する。
const A = [1, 2, 3];
const B = [4, 5, 6];

// A, Bの積集合は空集合になる
const A_and_B = intersection(A, B);
console.log(A_and_B); // []

// A, Bの和集合
const A_or_B = union(A, B);

// A, Bには共通の要素がないのだから
// A, Bの和集合の要素の数は、集合A, Bそれぞれの要素の数の和と一致する
const count = n(A_or_B);
const sum   = n(A) + n(B);

// A, Bの和集合の要素数も、集合 A, Bそれぞれの要素数の和も6であった。
console.log(count, sum); // 6, 6
```



### ケース②

$$
A \cap B \neq \phi のとき \\
A \cap B の部分は重複して数える事になるので \\
n(A \cup B) = n(A) + n(B) + n(A \cap B)
$$



これをプログラムで表現するとこのようになる。

```js
// 集合A, Bの積集合はφではないので、共通する要素を持つ集合を用意する。
// 集合A, B
const A = [1, 2, 3];
const B = [2, 3, 4];

// A, Bの和集合と積集合を求める
const A_or_B  = union(A, B);
const A_and_B = intersection(A, B);

// A, Bの和集合の要素数は
// 集合A, B の要素数の和から、A, Bに共通する要素の数を差し引かなければならないため
// A, Bの積集合の要素数を差し引く
const count = n(A_or_B);
const num   = n(A) + n(B) - n(A_and_B);

console.log(count, num); // 4, 4
```


$$
またケース①のA \cap B = \phi の場合でも \\
n(A \cap B) = 0 であるため、上記と同様の計算で要素数が求まる \\
n(A \cup B) = n(A) + n(B) + n(A \cap B) \\
= n(A) + n(B) + 0
$$
これをプログラムで表現するとこのようになる。

```js
// 集合A, Bの積集合はφなので、共通する要素を持たない集合を用意する。
// 集合A, B
const A = [1, 2, 3];
const B = [4, 5, 6];

// A, Bの和集合と積集合を求める
const A_or_B  = union(A, B);
const A_and_B = intersection(A, B);

// A, Bの和集合の要素数は、集合 A,Bの要素数の和だが
// A, Bの積集合はφ(つまりn(φ) = 0)となるため、以下の計算式で求まる。
const count = n(A_or_B);
const num   = n(A) + n(B) - n(A_and_B);

console.log(count, num); // 6, 6
```



## 全体集合

> 全体集合とは、「考えている対象全体」を表す集合のことです。
>
> 英語で Universal Set と言うので、全体集合は **U**という記号であらわす事が多い



問題で「10以下の正の整数を全体集合Uとして」、といった形で出題された場合

全体集合Uは以下のように表せる。
$$
U = \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10 \}
$$
とりあえず「今考えている要素はこれが全て」となる集合を**全体集合**と呼ぶ。



## 部分集合

> 部分集合とは、ある集合の中から一部(あるいは全部)を取り出してきたもの。



集合Uがあるとして

$$
U = \{ 1, 2, 3, 4, 5 \} \\
$$

Uの中から一部を取り出した、例えば以下のような集合は全て部分集合である。
$$
A = \{1 \} \\
B = \{2 \} \\
C = \{1, 2\}
$$
また元の集合と同じ集合や、空集合も部分集合と呼ばれる。

つまり以下の集合も集合Uの部分集合と呼ぶ。
$$
A = \phi \\
B = \{1, 2, 3, 4, 5\}
$$
集合Uと、Uの部分集合Aがあった時、以下の記号で表される。
$$
A \subseteq U
$$


実は部分集合を表す記号は２つの流儀があるらしく、人によって使う記号が違うらしいが

ここでは上記の書き方とする。



部分集合を表す記号をプログラムで考えるとするとこのような感じだろうか。

```js
// 集合Aが集合Bの部分集合かどうかを判定する
function subseteq(A, B) {

  // まず部分集合Aの要素数が集合Bの要素数を超えてたら部分集合にならない
  if (B.length < A.length) return false;

  // 集合Aの要素が集合Bに含まれる事を確認
  for (let i = 0, num = A.length; i < num; ++i) {
    if (B.indexOf(A[i]) === -1) return false;
  }

  return true;
}

// 全体集合Uを定義
const U = [1, 2, 3, 4, 5];

// 第一引数に与えた集合がUの部分集合ならtrue
console.log(subseteq([], U));
console.log(subseteq([1, 2], U));
console.log(subseteq([2, 3, 4], U));
console.log(subseteq([1, 2, 3, 4, 5], U));

// 部分集合じゃないならfalse
console.log(subseteq([6, 7], U));
```



## 真部分集合

> 真部分集合とは、ある集合の中から一部を取り出してきたもの。

以下の集合Uがあったとして
$$
U = \{1, 2, 3, 4, 5\}
$$
以下の集合は真部分集合
$$
A = \{1 \} \\
B = \{2 \} \\
C = \{1, 2\}
$$
素の集合の要素から**一部のみを取り出した集合**を真部分集合と呼ぶ。



そのため、以下は真部分集合ではない。
$$
A = \{1, 2, 3, 4, 5 \}
$$
元の集合の要素を**全て取り出した集合**は部分集合ではあるが、真部分集合ではないという事である。



集合Uと、Uの真部分集合Aがあった時、以下の記号で表される。
$$
A \subset U
$$


真部分集合を表す記号をプログラムで考えるとするとこのような感じだろうか。

```js
// 集合Aが集合Bの真部分集合かどうかを判定する
function subset(A, B) {
  // Aが真部分集合であれば、集合Bの要素数未満でなければいけない
  if (B.length <= A.length) return false;

  // 集合Aの要素が集合Bに含まれる事を確認
  for (let i = 0, num = A.length; i < num; ++i) {
    if (B.indexOf(A[i]) === -1) return false;
  }

  return true;  
}

// 全体集合Uを定義
const U = [1, 2, 3, 4, 5];

// 真部分集合ならtrue
console.log(subset([], U));
console.log(subset([1, 2], U));
console.log(subset([2, 3, 4], U));

// 真部分集合じゃないならfalse
console.log(subset([6, 7], U))

// 同じ集合を比較した場合、部分集合ではあるが、真部分集合ではない。
console.log(subseteq(U, U)); // true
console.log(subset(U, U));   // false
```





## 補集合

> A の補集合とは、全体集合の要素の中で、部分集合Aに含まれないものを集めた集合の事です。



例えば、「10以下の正の整数を全体集合U、1桁の正の偶数を部分集合A」とする


$$
U = \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10 \} \\
A = \{2, 4, 6, 8\}
$$
この時、Aの補集合は 全体集合Uのうち、A 以外の要素となり、Aの上にバーを書いて以下のように表す。
$$
\overline{A} = \{1, 3, 5, 7, 9, 10\}
$$


補集合の記号をプログラムで実現するとなると

**「引数に全体集合Uと部分集合Aを受け取り、全体集合UからAの要素を除いた配列を返す関数」**となる



```js
// 引数に部分集合Aと全体集合Uを受け取り、Aの補集合を求める関数
// AがUの部分集合になっているかどうかの判定は行わないものとする
function complement(A, U) {
  return U.filter((x) => {
    return A.indexOf(x) === -1;
  })
}

// 全体集合U、部分集合Aを準備
const U = [1, 2, 3, 4, 5];
const A = [2, 4, 5];

// Aの補集合
console.log(complement(A, U)); // [1, 3]
```



## 補集合の要素の数

$$
全体集合Uと、Uの部分集合A、Aの補集合 \overline{A} があるとき
$$

まず以下が成り立つ
$$
A \cup \overline{A} = U \\
A \cap \overline{A} = \phi
$$
部分集合Aと**A以外であるAの補集合**の和集合は当然全体集合Uになるし

部分集合AとAの補集合に共通する要素はないのだから、積集合は空集合になる。



全体集合の要素の数は以下の計算で求められる。
$$
n(U) = n(A \cup \overline{A}) = n(A) + n(\overline{A})
$$
この式をAの補集合について整理する事で、補集合の要素の数を求める式が得られる。
$$
n(U) = n(A) + n(\overline{A}) \\
両辺を入れ替える \\
n(A) + n(\overline{A}) = n(U) \\
n(\overline{A}) = n(U) - n(A)
$$
要するに**補集合の要素の数**は全体集合Uの要素数と部分集合Aの要素数の差である。

当たり前と言えば当たり前の話。



一応プログラムでもこの計算を確かめてみるとする。

```js
// 全体集合U、部分集合Aを準備
const U = [1, 2, 3, 4, 5];
const A = [2, 4, 5];

// Aの補集合の要素数は2のはず
const count = n(U) - n(A);
console.log(count); // 2

// 実際にAの補集合の要素数も表示してみる
const comp = complement(A, U);
console.log(n(comp)); // 2
```