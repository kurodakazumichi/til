# Haskell: const function

- Prelude library は 以下のような const関数を定義する

`const x _ = x`

- 二番目の引数がなんであろうと、const関数はつねに第一引数を返す。
- 以下のようなlength関数を実装できる。

```
Prelude> let length = sum.map(const 1)
```

ちょっとこれだけじゃ意味がわからないな

---
書籍が少し辛いので、こっちを見てみる
https://qiita.com/7shi/items/145f1234f8ec2af923ef
---

# 束縛
Haskellの変数は再代入できないので、代入ではなく**束縛**という用語を使う。

確かに不変なのに代入という言葉を使うのには違和感を感じていて
束縛と行った方がすっきりする。

(むしろ変数も不変なものしかない、というなら実質変数ではなくて定数なのでは...)
定数しか定義できませんと言われると、それはそれでなるほどってなる気もした

# トップレベル変数
要するにグローバル変数

```hs
a = 1
b = 2
c = a + b
main = do
  print c
```

特にキーワードもなく普通に書くだけ。

# ローカル変数
書き方が２つあるらしい

## where

```hs
main = do 
  print c
  where
    a = 1
    b = 2
    c = a + b
```

実際に使うところの**下**に書く方法が`where`を使う方法らしい

## let

```hs
main = do 
  let a = 1
      b = 2
      c = a + b
  print c
```

変数を定義してから使う方法は`let`
これは普通の手続き型と同じ感じなので違和感はない

```hs
main =
  let a = 1
      b = 2
      c = a + b in
  print c
```

`do`がない場合は`in`と言われても...
`do`がある事で複数行書ける
`do`がなくなると`let`と`print`の２文は描けないので`in`で繋ぐと1文になる感じかな

# 関数

- Haskellの関数定義はとても質素

## 以下でJSの関数定義とHaskellの関数定義を比較

- js:`function f(x) { return x + 1; }
- hs:`f x = x + 1`

## 関数の実行

- js:`f(1)`
- hs:`f 1`

- `print f 1`はエラーになる
- `print (f 1)`ならOK

関数実行に`()`がないので、 `()`がないと  
`f 1`が`print`に渡す引数なのか、それとも関数実行なのか区別できないためであろう

## 相違点

- Haskellでは関数定義時の`()`や`{}`や戻り値のための`return`がない
- 関数実行時も`関数名 引数`という形で`()`がない
- 慣れないと読みづらいが、簡潔な書き方と言える


# $
`$`から行末までが、カッコで囲まれたのと同じになる。

```hs
f x = x + 1

main = do 
  print (f 1)  -- ①
  print $ f 1  -- ②
  -- ①と②は同じもの
```

# 関数の演算子化

- 2つの引数をとる関数を**`**で囲むと演算子として仕様できる ← これ面白い

```hs
add x y = x + y
 
main = do
  print $ add 1 2
  print $ 1 `add` 2 -- 1 + 2 という感覚でかける
```

# 演算子の関数化

中置演算子を`()`で囲むと関数として使える

```hs
add x y = x + y
 
main = do
  print $ 1 + 2
  print $ (+) 1 2 -- +を関数として使える
```

# if then else

- １行で書く例

```hs
a = 1

main = do
    if a == 1 then print "1" else print "?"
```

- 複数行で書く場合はインデントする必要あり

```hs
a = 1

main = do
  if a == 1 
    then print "1" 
    else print "?"
```
    
- ifは値を返す

```hs
f a = if a == 1 then "1" else "?" -- 三項演算子的なもの

main = do
  print $ f 0
  print $ f 1
```

# パターンマッチ

- Haskellでは`if`で分岐するかわりに、特定の引数の場合はこっち  
のようにパターンで処理を分けて定義することができる。

```hs
f 1 = "1" -- 引数が1なら"1"
f a = "?" -- 引数がそれ以外なら"?"

main = do
  print $ f 0
  print $ f 1
```

- 関数のオーバーロードと近いが、型だけでなく直値でもパターンマッチできる点が良いと思った

- 値を無視する引数は`_`と書く事で、この引数は無視(なんであってもいい)という事を明示する。

```hs
f 1 = "1"
f _ = "?"
```

# 階乗

階乗はこういうやつ→`5! = 5 * 4 * 3 * 2 * 1`

```hs
fact 0 = 1
fact n = n * fact (n - 1)

main = do
  print $ fact 5
```

詳しくはここで
https://qiita.com/7shi/items/145f1234f8ec2af923ef#%E9%9A%8E%E4%B9%97

- 要するに再起関数の書き方
- 再起は手続き型で書く場合も混乱するしそもそも混乱しやすい、が
- 慣れるとHaskellの書き方がシンプルでわかりやすい気がする
- 簡約という表現、また基底部、再起部と分けて考える事に慣れたい。

手続き型と比べて混乱するのは、式が展開されているイメージの部分
明示的にfor文などがないので繰り返し処理されているという感覚が掴みにくい
これは手続き型の考え方に慣れてしまっているせいで
より完結な数学的な考え方がすんなり理解できない事に起因している気がする。


# ガード

関数の中に引数の条件を列挙して、その条件に一致したところに処理書くっていう
ガードという書き方があるそうな。

```hs
fact n
    | n == 0    = 1
    | otherwise = n * fact (n - 1)

main = do
    print $ fact 5
```

- パターンマッチとやっていることは大差ない


# パターンマッチとガードの使い分け

- パターンマッチは`switch`-`case`の強化版
- ガードは`if`-`else if`の羅列

- パターンマッチでかけるならそれに越したことはないけど、無理ならガードも合わせて使う
そんな温度感

# case - of

パターンマッチとガードの別な書き方？

```hs
fact n = case n of
  0 -> 1
  _ | n > 0 -> n * fact (n - 1)

main = do 
  print $ fact 5
```

大抵はパターンマッチとガードですむらしく、使用頻度は低いとのこと
これは使うケースが出てくるまで深堀はしないでおこう。

# リスト

```hs
main = do
  print [1, 2, 3, 4, 5]
```

# !!

リストから要素をとりだす。

```hs
main = do
  print $ [1,2,3,4,5] !! 3 -- 4と表示される
```

# 連番
```hs
main = do
  print [1..5] -- [1, 2, 3, 4, 5]と表示される
```

# ++

```hs
main = do
  print $ [1, 2, 3] ++ [4, 5] -- リストの結合
```

# :
`:`でリストの先頭に要素を挿入できる。

```
main = do
  print $ 1:[2..5]   -- [1, 2, 3, 4, 5]
  print $ 1:2:[3..5] -- [1, 2, 3, 4, 5]
```

# 文字列

文字列は文字のリスト、C言語やってればさほど違和感はない。

```hs
main = do
  print $ "abcde"
  print $ ['a', 'b', 'c', 'd', 'e']
  print $ ['a' .. 'e']
  print $ 'a':"bcde"
  print $ 'a':'b':"cde"
  print $ "abc" ++ "de"
  print $ "abcde" !! 3
```

## 引数、リストを分割してうけとる

- リストの先頭をうけとる
```hs
first (x:_) = x

main = do
  print $ first [1..5]   -- 1
  print $ first "abcdef" -- 'a'
```

- リストの2番目をうけとる

```hs
second (_:x:_) = x

main = do
  print $ second [1..5]
  print $ second "abcdef"
```

# リスト関係の関数

```hs
main = do
  print $ length [1,2,3]   -- 3                長さ
  print $ sum [1..5]       -- 15               足し算
  print $ product [1..5]   -- 120              掛け算
  print $ take 2 [1,2,3]   -- [1,2]            要素をとる
  print $ drop 2 [1, 2, 3] -- [3]              要素を落とす
  print $ reverse [1..5]   -- [5, 4, 3, 2, 1]  逆順そーと
```

# タプル

- 関数で複数の値を返すことができる。
- カッコで複数の値を囲んだ部分をタプルと呼ぶ。

```hs
addsub x y = (x + y, x - y)

main = do
  print $ addsub 1 2
```

- タプルの結果受け取り

```hs
addsub x y = (x + y, x - y)
a        = addsub 1 2 -- aは(3, -1)
(a1, a2) = addsub 1 2 -- a1は3、a1は-1
```

# タプル向けの関数

- `fst`:最初の値を取得
- `snd`:２個目の値を取得

```hs
main = do
  let p2 = (1, 2)
  print $ fst p2 -- 1
  print $ snd p2 -- 2
```

- 要素が3つ以上だったら、分割で取得する


```hs
main = do
  let p3 = (1, 2, 3)
  print p3 -- (1, 2, 3)
  let (_, _, p3z) = p3
  print p3z -- 3
```
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




